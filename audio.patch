From 09e6c83e0b2231eb1c686b1f99aa921b5d2ed362 Mon Sep 17 00:00:00 2001
From: Evelyn Hung <jj.evelyn@gmail.com>
Date: Mon, 21 Sep 2015 17:38:27 +0800
Subject: [PATCH] Bug 1206621 - Back port AudioChannelManager to smart-system

---
 tv_apps/smart-system/index.html                    |   1 +
 tv_apps/smart-system/js/app_window.js              |  34 +++
 tv_apps/smart-system/js/app_window_manager.js      |   4 +-
 .../smart-system/js/audio_channel_controller.js    | 328 +++++++++++++++++++++
 tv_apps/smart-system/js/audio_channel_policy.js    | 295 ++++++++++++++++++
 tv_apps/smart-system/js/audio_channel_service.js   | 292 ++++++++++++++++++
 tv_apps/smart-system/js/core.js                    |   4 +
 tv_apps/smart-system/js/system_window.js           |  82 ++++++
 8 files changed, 1038 insertions(+), 2 deletions(-)
 create mode 100644 tv_apps/smart-system/js/audio_channel_controller.js
 create mode 100644 tv_apps/smart-system/js/audio_channel_policy.js
 create mode 100644 tv_apps/smart-system/js/audio_channel_service.js
 create mode 100644 tv_apps/smart-system/js/system_window.js

diff --git a/tv_apps/smart-system/index.html b/tv_apps/smart-system/index.html
index cd33bdf..bb76375 100644
--- a/tv_apps/smart-system/index.html
+++ b/tv_apps/smart-system/index.html
@@ -44,6 +44,7 @@
 
     <script defer src="js/service.js"></script>
     <script defer src="js/base_ui.js"></script>
+    <script defer src="js/audio_channel_controller.js"></script>
 
     <script defer src="js/orientation_manager.js"></script>
     <!--
diff --git a/tv_apps/smart-system/js/app_window.js b/tv_apps/smart-system/js/app_window.js
index c7255f8..6d785db 100644
--- a/tv_apps/smart-system/js/app_window.js
+++ b/tv_apps/smart-system/js/app_window.js
@@ -1,4 +1,5 @@
 /* global AppChrome */
+/* global AudioChannelController */
 /* global BrowserFrame */
 /* global layoutManager */
 /* global ManifestHelper */
@@ -667,6 +668,9 @@
       this.iframe = this.browser.element;
       this.launchTime = Date.now();
       this.appChrome && this.appChrome.reConfig();
+      // Register audio channels for new browser frame.
+      this._unregisterAudioChannels();
+      this._registerAudioChannels();
     }
 
     this.browser.element.src = url;
@@ -735,6 +739,11 @@
         }
       }
 
+      // Need to wait for mozbrowserloadend to get allowedAudioChannels.
+      this.browser.element.addEventListener('mozbrowserloadend', () => {
+        this._registerAudioChannels();
+      });
+
       if (this.manifest) {
         var that = this;
         that.element.addEventListener('_opened', function onOpened() {
@@ -755,12 +764,37 @@
         this[componentName] = null;
       }
 
+      this._unregisterAudioChannels();
+
       if (this.appChrome) {
         this.appChrome.destroy();
         this.appChrome = null;
       }
     };
 
+  AppWindow.prototype._registerAudioChannels =
+    function aw_registerAudioChannels() {
+      this.audioChannels = new Map();
+      var audioChannels = this.browser.element.allowedAudioChannels;
+      audioChannels && audioChannels.forEach((audioChannel) => {
+        this.audioChannels.set(
+          audioChannel.name,
+          new AudioChannelController(this, audioChannel)
+        );
+        this.debug('Registered ' + audioChannel.name + ' audio channel');
+      });
+    };
+
+  AppWindow.prototype._unregisterAudioChannels =
+    function aw_unregisterAudioChannels() {
+      if (this.audioChannels) {
+        this.audioChannels.forEach(function(audioChannel) {
+          audioChannel.destroy();
+        });
+        this.audioChannels = null;
+      }
+    };
+
   AppWindow.prototype._handle__localized = function aw__handle__localized() {
     if (!this.manifest) {
       return;
diff --git a/tv_apps/smart-system/js/app_window_manager.js b/tv_apps/smart-system/js/app_window_manager.js
index 9e49af9..93d873f 100644
--- a/tv_apps/smart-system/js/app_window_manager.js
+++ b/tv_apps/smart-system/js/app_window_manager.js
@@ -434,8 +434,8 @@
         case 'homescreenterminated':
         case 'appterminated':
           var app = evt.detail; // jshint ignore:line
-          var instanceID = evt.detail.instanceID;
-          if (activeApp && app.instanceID === activeApp.instanceID) {
+          var instanceID = app.instanceID;
+          if (activeApp && instanceID === activeApp.instanceID) {
             activeApp = null;
           }
           delete this._apps[instanceID];
diff --git a/tv_apps/smart-system/js/audio_channel_controller.js b/tv_apps/smart-system/js/audio_channel_controller.js
new file mode 100644
index 0000000..2d70f14
--- /dev/null
+++ b/tv_apps/smart-system/js/audio_channel_controller.js
@@ -0,0 +1,328 @@
+/* global BaseUI */
+'use strict';
+
+(function(exports) {
+  var FADE_IN_VOLUME = 1;
+  var FADE_OUT_VOLUME = 0.2;
+  var VIBRATION_DURATION = 1000;
+
+  /**
+   * AudioChannelController controls the audio channel to
+   * play or pause.
+   *
+   * There are two ways to create an AudioChannelController instance.
+   * One is for System app, and the other one is for other apps. 
+   *
+   * Doing `new AudioChannelController('notification')`
+   * to create a controller for System app's notification audio channel.
+   *
+   * Doing `new AudioChannelController(musicApp, contentChannel)`
+   * to create a controller for Music app's content audio channel.
+   * 
+   * @param {AppWindow|String} app
+   * If you want to create a controller for System app's audio channel,
+   * use a String.
+   * If you want to create a controller for other app's audio channel,
+   * use a AppWindow.
+   * @param {BrowserElementAudioChannel} channel
+   * An audio channel belongs to the app.
+   */
+  var AudioChannelController = function(app, channel) {
+    this.app = app;
+    this.name = channel.name;
+    this._channel = channel;
+    if (app.isSystem) {
+      window.addEventListener('mozChromeEvent', this);
+    } else {
+      channel.addEventListener('activestatechanged', this);
+    }
+    this._states = {
+      active: false,
+      playing: false,
+      fadingOut: false,
+      vibrating: false
+    };
+    this._policy = {};
+    this._generateID();
+  };
+
+  AudioChannelController.prototype = Object.create(BaseUI.prototype); 
+
+  AudioChannelController.prototype.EVENT_PREFIX = 'audiochannel';
+
+  /**
+   * General event handler interface.
+   *
+   * @param {Event} evt The event to handle.
+   */
+  AudioChannelController.prototype.handleEvent = function(evt) {
+    switch (evt.type) {
+      case 'activestatechanged':
+        var channel = evt.target;
+        // TODO: We should get the `isActive` state from evt.isActive.
+        // Then we don't need to do `channel.isActive()` here.
+        channel.isActive().onsuccess = (evt) => {
+          this._states.active = evt.target.result;
+          this.publish('statechanged');
+        };
+        break;
+
+      case 'mozChromeEvent':
+        var detail = evt.detail;
+        var name = detail.name;
+        switch (detail.type) {
+          case 'system-audiochannel-state-changed':
+            if (name === this.name) {
+              this._states.active = detail.isActive;
+              this.publish('statechanged');
+            }
+            break;
+
+          case 'system-audiochannel-mute-onsuccess':
+            name === this.name &&
+              this.debug('Set muting state of audio channel as ' +
+                detail.isMuted);
+            break;
+
+          case 'system-audiochannel-mute-onerror':
+            name === this.name &&
+              this.debug('Cannot set muting state of audio channel as ' +
+                detail.isMuted);
+            break;
+
+          case 'system-audiochannel-volume-onsuccess':
+            name === this.name &&
+              this.debug('Set volume of the audio channel as ' +
+                detail.volume);
+            break;
+
+          case 'system-audiochannel-volume-onerror':
+            name === this.name &&
+              this.debug('Cannot set volume of the audio channel as ' +
+                detail.volume);
+            break;
+        }
+        break;
+    }
+  };  
+
+  /**
+   * Set the policy for handling this audio channel.
+   *
+   * @param {Object} policy Policy to handle this audio channel.
+   * @param {Boolean} [policy.isAllowedToPlay] Play or pause it.
+   * @param {Boolean} [policy.isNeededToFadeOut] Fade out or not.
+   * @param {Boolean} [policy.isNeededToVibrate] Vibrate or not.
+   * @param {Boolean} [policy.isNeededToResumeWhenOtherEnds]
+   * Resume when other audio channel ends if as true.
+   * @return {AudioChannelController}
+   */
+  AudioChannelController.prototype.setPolicy = function(policy) {
+    this._policy = policy || this._policy;
+    return this;
+  };
+
+  AudioChannelController.prototype.getPolicy = function() {
+    return this._policy;
+  };
+
+  /**
+   * Handle the audio channel with the policy.
+   *
+   * @return {AudioChannelController}
+   */
+  AudioChannelController.prototype.proceedPolicy = function() {
+    var policy = this._policy;
+    if (policy.isAllowedToPlay) {
+      this._play();
+    } else if (policy.isAllowedToPlay != null) {
+      this._pause();
+    }
+    if (policy.isNeededToFadeOut) {
+      this._fadeOut();
+    } else if (policy.isNeededToFadeOut != null) {
+      this._fadeIn();
+    }
+    if (policy.isNeededToVibrate) {
+      this._vibrate();
+    }
+    return this;
+  };
+
+  /**
+   * Get active state.
+   *
+   * @return {Boolean}
+   */
+  AudioChannelController.prototype.isActive = function() {
+    return this._states.active;
+  };
+
+  /**
+   * Get state of playing.
+   *
+   * @return {Boolean}
+   */
+  AudioChannelController.prototype.isPlaying = function() {
+    return this._states.playing;
+  };
+
+  /**
+   * Get state of fading out.
+   *
+   * @return {Boolean}
+   */
+  AudioChannelController.prototype.isFadingOut = function() {
+    return this._states.fadingOut;
+  };
+
+  /**
+   * Get state of vibrating.
+   *
+   * @return {Boolean}
+   */
+  AudioChannelController.prototype.isVibrating = function() {
+    return this._states.vibrating;
+  };
+
+  AudioChannelController.prototype.destroy = function() {
+    this.publish('destroyed');
+  };
+
+  /**
+   * Play the audio channel.
+   */
+  AudioChannelController.prototype._play = function() {
+    this._states.playing = true;
+    if (this.app.isSystem) {
+      this._sendContentEvent({
+        type: 'system-audiochannel-mute', isMuted: false
+      });
+    } else {
+      var promise = new Promise((resolve) => {
+        var request = this._channel.setMuted(false);
+        request.onsuccess = () => {
+          resolve();
+        };
+        request.onerror = () => {
+          throw 'Cannot play the audio channel.';
+        };
+      });
+      promise.then(() => {
+        this.app.debug('Play the audio channel.');
+      }).catch(e => {
+        this.app.debug(e);
+      });
+    }
+  };
+
+  /**
+   * Fade in the audio channel.
+   */
+  AudioChannelController.prototype._fadeIn = function() {
+    this._setVolume(FADE_IN_VOLUME);
+    this._states.fadingOut = false;
+  },
+
+  /**
+   * Fade out the audio channel.
+   */
+  AudioChannelController.prototype._fadeOut = function() {
+    this._setVolume(FADE_OUT_VOLUME);
+    this._states.fadingOut = true;
+    !this._states.playing && this._play();
+  },
+
+  /**
+   * Pause the audio channel.
+   */
+  AudioChannelController.prototype._pause = function() {
+    this._states.playing = false;
+    if (this.app.isSystem) {
+      this._sendContentEvent({
+        type: 'system-audiochannel-mute', isMuted: true
+      });
+    } else {
+      var promise = new Promise((resolve) => {
+        var request = this._channel.setMuted(true);
+        request.onsuccess = () => {
+          resolve();
+        };
+        request.onerror = () => {
+          throw 'Cannot pause the audio channel.';
+        };
+      });
+      promise.then(() => {
+        this.app.debug('Pause the audio channel');
+      }).catch(e => {
+        this.app.debug(e);
+      });
+    }
+  };
+
+  /**
+   * Vibrate for one second
+   * and the vibration pattern is [200, 100, 200, 100, ...].
+   */
+  AudioChannelController.prototype._vibrate = function() {
+    var intervalId = setInterval(() => {
+      navigator.vibrate(200);
+    }, 300);
+    this._states.vibrating = true;
+    setTimeout(() => {
+      clearInterval(intervalId);
+      this._states.vibrating = false;
+    }, VIBRATION_DURATION);
+  };
+
+  /**
+   * Change volume of audio channels.
+   *
+   * @param {Number} volume 0 to 1.
+   */
+  AudioChannelController.prototype._setVolume = function(volume) {
+    if (this.app.isSystem) {
+      this._sendContentEvent({
+        type: 'system-audiochannel-volume', volume: volume
+      });
+    } else {
+      var promise = new Promise((resolve) => {
+        var request = this._channel.setVolume(volume);
+        request.onsuccess = () => {
+          resolve();
+        };
+        request.onerror = () => {
+          throw 'Cannot set volume of the audio channel.';
+        };
+      });
+      promise.then(() => {
+        this.app.debug('Set volume: ' + volume);
+      }).catch(e => {
+        this.app.debug(e);
+      });
+    }
+  };
+
+  /**
+   * Generate instance ID.
+   */
+  AudioChannelController.prototype._generateID = function() {
+    this.instanceID = this.app.instanceID + '_' + this.name;
+  };
+
+  /**
+   * Send MozContentEvent to control the audio chanenl in System app.
+   *
+   * @param {Object} detail The arguments for passing to Gecko.
+   * @param {Object} detail.type The operation for the audio channel.
+   * @param {Object} detail.isMuted Allow audio channel to play or not.
+   * @param {Object} detail.volume The volume you want to set.
+   */
+  AudioChannelController.prototype._sendContentEvent = function(detail) {
+    detail.name = this.name;
+    var evt = new CustomEvent('mozContentEvent', { detail: detail });
+    window.dispatchEvent(evt);
+  };
+
+  exports.AudioChannelController = AudioChannelController;
+}(window));
diff --git a/tv_apps/smart-system/js/audio_channel_policy.js b/tv_apps/smart-system/js/audio_channel_policy.js
new file mode 100644
index 0000000..15c8f13
--- /dev/null
+++ b/tv_apps/smart-system/js/audio_channel_policy.js
@@ -0,0 +1,295 @@
+/* global BaseModule */
+'use strict';
+
+(function() {
+  // The results of audo channel competition.
+  var PLAY = true;
+  var PAUSE = false;
+  /**
+   * It is the table to get the result of
+   * the competition of audio channels.
+   *
+   * Get the result of the competition
+   * of normal and content audio channels with
+   * `AUDIO_CHANNEL_COMPETITION_RESULTS.normal.content`.
+   */
+  var AUDIO_CHANNEL_COMPETITION_RESULTS = {
+    normal: {
+      normal: { activeAudioChannel: PAUSE, newAudioChannel: PLAY },
+      content: { activeAudioChannel: PAUSE, newAudioChannel: PLAY },
+      alarm: { activeAudioChannel: PAUSE, newAudioChannel: PLAY },
+      system: { activeAudioChannel: PLAY, newAudioChannel: PLAY },
+      ringer: { activeAudioChannel: PAUSE, newAudioChannel: PLAY },
+      telephony: { activeAudioChannel: PAUSE, newAudioChannel: PLAY },
+      notification: { activeAudioChannel: PLAY, newAudioChannel: PLAY },
+      publicNotification: { activeAudioChannel: PLAY, newAudioChannel: PLAY }
+    },
+    content: {
+      normal: { activeAudioChannel: PAUSE, newAudioChannel: PLAY },
+      content: { activeAudioChannel: PAUSE, newAudioChannel: PLAY },
+      alarm: { activeAudioChannel: PAUSE, newAudioChannel: PLAY },
+      system: { activeAudioChannel: PLAY, newAudioChannel: PLAY },
+      ringer: { activeAudioChannel: PAUSE, newAudioChannel: PLAY },
+      telephony: { activeAudioChannel: PAUSE, newAudioChannel: PLAY },
+      notification:  { activeAudioChannel: PLAY, newAudioChannel: PLAY },
+      publicNotification:  { activeAudioChannel: PLAY, newAudioChannel: PLAY }
+    },
+    alarm: {
+      normal: { activeAudioChannel: PLAY, newAudioChannel: PLAY },
+      content: { activeAudioChannel: PLAY, newAudioChannel: PLAY },
+      alarm: { activeAudioChannel: PAUSE, newAudioChannel: PLAY },
+      system: { activeAudioChannel: PLAY, newAudioChannel: PLAY },
+      ringer: { activeAudioChannel: PLAY, newAudioChannel: PLAY },
+      telephony: { activeAudioChannel: PLAY, newAudioChannel: PLAY },
+      notification: { activeAudioChannel: PLAY, newAudioChannel: PLAY },
+      publicNotification: { activeAudioChannel: PLAY, newAudioChannel: PLAY }
+    },
+    system: {
+      normal: { activeAudioChannel: PLAY, newAudioChannel: PLAY },
+      content: { activeAudioChannel: PLAY, newAudioChannel: PLAY },
+      alarm: { activeAudioChannel: PLAY, newAudioChannel: PLAY },
+      system: { activeAudioChannel: PLAY, newAudioChannel: PLAY },
+      ringer: { activeAudioChannel: PLAY, newAudioChannel: PLAY },
+      telephony: { activeAudioChannel: PLAY, newAudioChannel: PLAY },
+      notification: { activeAudioChannel: PLAY, newAudioChannel: PLAY },
+      publicNotification: { activeAudioChannel: PLAY, newAudioChannel: PLAY }
+    },
+    ringer: {
+      normal: { activeAudioChannel: PLAY, newAudioChannel: PLAY },
+      content: { activeAudioChannel: PLAY, newAudioChannel: PLAY },
+      alarm: { activeAudioChannel: PLAY, newAudioChannel: PLAY },
+      system: { activeAudioChannel: PLAY, newAudioChannel: PLAY },
+      ringer: { activeAudioChannel: PAUSE, newAudioChannel: PLAY },
+      telephony: { activeAudioChannel: PLAY, newAudioChannel: PLAY },
+      notification: { activeAudioChannel: PLAY, newAudioChannel: PLAY },
+      publicNotification: { activeAudioChannel: PLAY, newAudioChannel: PLAY }
+    },
+    telephony: {
+      normal: { activeAudioChannel: PLAY, newAudioChannel: PLAY },
+      content: { activeAudioChannel: PLAY, newAudioChannel: PLAY },
+      alarm: { activeAudioChannel: PLAY, newAudioChannel: PAUSE },
+      system: { activeAudioChannel: PLAY, newAudioChannel: PLAY },
+      ringer: { activeAudioChannel: PLAY, newAudioChannel: PAUSE },
+      notification: { activeAudioChannel: PLAY, newAudioChannel: PAUSE },
+      publicNotification: { activeAudioChannel: PLAY, newAudioChannel: PLAY }
+    },
+    notification: {
+      normal: { activeAudioChannel: PLAY, newAudioChannel: PLAY },
+      content: { activeAudioChannel: PLAY, newAudioChannel: PLAY },
+      alarm: { activeAudioChannel: PLAY, newAudioChannel: PLAY },
+      system: { activeAudioChannel: PLAY, newAudioChannel: PLAY },
+      ringer: { activeAudioChannel: PLAY, newAudioChannel: PLAY },
+      telephony: { activeAudioChannel: PLAY, newAudioChannel: PLAY },
+      notification: { activeAudioChannel: PLAY, newAudioChannel: PLAY },
+      publicNotification: { activeAudioChannel: PLAY, newAudioChannel: PLAY }
+    },
+    publicNotification: {
+      normal: { activeAudioChannel: PLAY, newAudioChannel: PLAY },
+      content: { activeAudioChannel: PLAY, newAudioChannel: PLAY },
+      alarm: { activeAudioChannel: PLAY, newAudioChannel: PLAY },
+      system: { activeAudioChannel: PLAY, newAudioChannel: PLAY },
+      ringer: { activeAudioChannel: PLAY, newAudioChannel: PLAY },
+      telephony: { activeAudioChannel: PLAY, newAudioChannel: PLAY },
+      notification: { activeAudioChannel: PLAY, newAudioChannel: PLAY },
+      publicNotification: { activeAudioChannel: PLAY, newAudioChannel: PLAY }
+    }
+  };
+
+  /**
+   * AudioChannelPolicy provides policies to handle audio channels.
+   */
+  var AudioChannelPolicy = function() {};
+
+  AudioChannelPolicy.SETTINGS = [
+    'vibration.enabled'
+  ];
+
+  BaseModule.create(AudioChannelPolicy, {
+    name: 'AudioChannelPolicy',
+    DEBUG: false,
+    // The value of the vibration.enabled settings.
+    _isVibrateEnabled: true,
+
+    /**
+     * Get the policies of 
+     * handling the new audio channel and active audio channels.
+     *
+     * @param {AudioChannelController} newAudioChannel
+     * A new audio channel you want to handle.
+     * @param {Map} activeAudioChannels
+     * Active audio channels playing noew.
+     * @param {Object} [options] Options.
+     * @param {Boolean} [options.isNewAudioChannelInBackground]
+     * Is the new audio channel in background.
+     */
+    applyPolicy: function(newAudioChannel, activeAudioChannels, options) {
+      var newAudioChannelName = newAudioChannel.name;
+      // Deconflict the conflicted policies for the new audio channel.
+      // For example, we have a new audio channel `alarm` and
+      // two active audio channels `system` and `telephony`.
+      // `AUDIO_CHANNEL_COMPETITION_RESULTS.system.alarm` is `true`,
+      // but `AUDIO_CHANNEL_COMPETITION_RESULTS.telephony.alarm`
+      // is `false`.
+      // And we get conflict policies for the `alarm` audio channel.
+      // Once we get conflcts, we will take higher priority policy.
+      // `PAUSE` is higher than `PLAY`,
+      // and doing fade out is higher than not doing fade out.
+      var isAllowedToPlayForNewAudioChannel = [true];
+      var isNeededToFadeOutForNewAudioChannel = [false];
+      // The new audio channel will be allowed to play,
+      // if any other audio channel belonged to its app is already playing.
+      var isNewAudioChannelsAppPlaying = false;
+      activeAudioChannels.forEach((audioChannel) => {
+        if (audioChannel.app.instanceID === newAudioChannel.app.instanceID) {
+          isNewAudioChannelsAppPlaying = true;
+        }
+      });
+      !isNewAudioChannelsAppPlaying &&
+        activeAudioChannels.forEach((audioChannel) => {
+        var activeAudioChannelName = audioChannel.name;
+        var results = AUDIO_CHANNEL_COMPETITION_RESULTS
+          [activeAudioChannelName][newAudioChannelName];
+        var policy = {
+          isAllowedToPlay: results.activeAudioChannel
+        };
+        if (results.activeAudioChannel) {
+          policy.isNeededToFadeOut =
+            this._isNeededToFadeOutForActiveAudioChannel(
+              activeAudioChannelName, newAudioChannelName
+            );
+        }
+        if (!results.activeAudioChannel) {
+          policy.isNeededToVibrate = this._isVibrateEnabled &&
+          this._isNeededToVibrateForActiveAudioChannel(
+            activeAudioChannelName, newAudioChannelName
+          );
+          policy.isNeededToResumeWhenOtherEnds =
+            this._isNeededToResumeWhenOtherEndsForActiveAudioChannel(
+              activeAudioChannelName, newAudioChannelName
+            );
+        }
+        audioChannel.setPolicy(policy);
+        this.debug('Policy for ' + audioChannel.instanceID +
+          ': ' + JSON.stringify(policy));
+        isAllowedToPlayForNewAudioChannel.push(results.newAudioChannel);
+        results.newAudioChannel && isNeededToFadeOutForNewAudioChannel.push(
+          this._isNeededToFadeOutForNewAudioChannel
+            (activeAudioChannelName, newAudioChannelName)
+        );
+      });
+      // Normal channel could not play in background.
+      if (newAudioChannelName === 'normal' &&
+          options && options.isNewAudioChannelInBackground) {
+        isAllowedToPlayForNewAudioChannel.push(false);
+      }
+      // Deconflict the policies.
+      isAllowedToPlayForNewAudioChannel =
+        isAllowedToPlayForNewAudioChannel.every(isAllowed => isAllowed);
+      isNeededToFadeOutForNewAudioChannel =
+        isNeededToFadeOutForNewAudioChannel.some(isNeeded => isNeeded);
+      var policy = {
+        isAllowedToPlay: isAllowedToPlayForNewAudioChannel
+      };
+      if (isAllowedToPlayForNewAudioChannel) {
+        policy.isNeededToFadeOut = isNeededToFadeOutForNewAudioChannel;
+      }
+      if (!isAllowedToPlayForNewAudioChannel) {
+        policy.isNeededToVibrate = this._isVibrateEnabled &&
+          !isAllowedToPlayForNewAudioChannel &&
+          // Don't vibrate for background normal audio channel.
+          newAudioChannelName !== 'normal';
+      }
+      newAudioChannel.setPolicy(policy);
+      this.debug('Policy for ' + newAudioChannel.instanceID +
+        ': ' + JSON.stringify(policy));
+    },
+
+    /**
+     * Observer the value of vibration.enabled settings.
+     *
+     * @param {Boolean} value The value of the settings.
+     */
+    '_observe_vibration.enabled': function(value) {
+      this._isVibrateEnabled = value;
+    },
+
+    /**
+     * Get the policy of fading out the new audio channel.
+     *
+     * @param {String} activeChannelName The active audio channel name.
+     * @param {String} newChannelName The new audio channel name.
+     * @return {Boolean}
+     */
+    _isNeededToFadeOutForNewAudioChannel:
+      function(activeChannelName, newChannelName) {
+      var isNeeded = false;
+      if ((activeChannelName === 'notification' ||
+           activeChannelName === 'publicNotification') &&
+          (newChannelName === 'normal' ||
+           newChannelName === 'content')
+         )
+      {
+        isNeeded = true;
+      }
+      return isNeeded;
+    },
+
+    /**
+     * Get the policy of fading out the active audio channel.
+     *
+     * @param {String} activeChannelName The active audio channel name.
+     * @param {String} newChannelName The new audio channel name.
+     * @return {Boolean}
+     */
+    _isNeededToFadeOutForActiveAudioChannel:
+      function(activeChannelName, newChannelName) {
+      var isNeeded = false;
+      if (((activeChannelName === 'normal' ||
+            activeChannelName === 'content') &&
+              (newChannelName === 'notification' ||
+               newChannelName === 'publicNotification')
+          ) ||
+          (activeChannelName === 'alarm' &&
+             (newChannelName === 'ringer' ||
+              newChannelName === 'telephony')
+          )
+         )
+      {
+        isNeeded = true;
+      }
+      return isNeeded;
+    },
+
+    /**
+     * Get the policy of vibrating for the active audio channel.
+     *
+     * @param {String} activeChannelName The active audio channel name.
+     * @param {String} newChannelName The new audio channel name.
+     * @return {Boolean}
+     */
+    _isNeededToVibrateForActiveAudioChannel:
+      function(activeChannelName, newChannelName) {
+      return activeChannelName === 'ringer' && newChannelName === 'ringer';
+    },
+
+    /**
+     * Get the policy of resuming the active audio channel
+     * when any other audio channel ends.
+     *
+     * @param {String} activeChannelName The active audio channel name.
+     * @param {String} newChannelName The new audio channel name.
+     * @return {Boolean}
+     */
+    _isNeededToResumeWhenOtherEndsForActiveAudioChannel:
+      function(activeChannelName, newChannelName) {
+      var isNeeded = true;
+      if (activeChannelName === 'normal' ||
+          (activeChannelName === 'content' && newChannelName === 'normal') ||
+          (activeChannelName === 'alarm' && newChannelName === 'alarm') ||
+          (activeChannelName === 'ringer' && newChannelName === 'ringer')) {
+        isNeeded = false;
+      }
+      return isNeeded;
+    }
+  });
+}());
diff --git a/tv_apps/smart-system/js/audio_channel_service.js b/tv_apps/smart-system/js/audio_channel_service.js
new file mode 100644
index 0000000..e9df002
--- /dev/null
+++ b/tv_apps/smart-system/js/audio_channel_service.js
@@ -0,0 +1,292 @@
+/* global BaseModule */
+/* global Service, AppWindowManager */
+'use strict';
+
+(function() {
+  /**
+   * AudioChannelService manages audio channels in apps.
+   * It could allow or deny a audio channel to play in some specific cases.
+   * For example, Music app would like to play when FM app is already playing.
+   * It will allow Music app to play, and pause FM app.
+   *
+   * @class AudioChannelService
+   */
+  var AudioChannelService = function() {};
+
+  AudioChannelService.EVENTS = [
+    'audiochannelstatechanged',
+    'audiochanneldestroyed',
+    'hierarchytopmostwindowchanged',
+    'systemwindowaudiochannelsregistered',
+    'appopened',
+    'appclosed'
+  ];
+
+  AudioChannelService.SUB_MODULES = [
+    'AudioChannelPolicy'
+  ];
+
+  BaseModule.create(AudioChannelService, {
+    name: 'AudioChannelService',
+    DEBUG: false,
+    // If true, all audio channels of System app are muted.
+    _isSystemMuted: false,
+    // A map contains playing audio channels.
+    _activeAudioChannels: null,
+    // An array contains audio channels could be resumed
+    // when any other audio channel ends.
+    _interruptedAudioChannels: null,
+    // The most top app window.
+    _topMostWindow: null,
+
+    /**
+     * Initial the module.
+     */
+    _start: function() {
+      this._activeAudioChannels = new Map();
+      this._interruptedAudioChannels = [];
+      this._muteSystemAudioChannels();
+      this.debug('Start Audio Channel Manager');
+    },
+
+    /**
+     * Handle the audio chanel when it is active or in inactive.
+     *
+     * @param {Event} evt The event to handle.
+     */
+    _handle_audiochannelstatechanged: function(evt) {
+      var audioChannel = evt.detail;
+      this.debug('Audio channel state is ' + audioChannel.isActive());
+      this._manageAudioChannels(audioChannel);
+    },
+
+    /**
+     * Remove the window's audio channels from
+     * `_activeAudioChannels` and `_interruptedAudioChannels`
+     * when the window is terminated.
+     *
+     * @param {Event} evt The event to handle.
+     */
+    _handle_audiochanneldestroyed: function(evt) {
+      var audioChannel = evt.detail;
+      this._activeAudioChannels.delete(audioChannel.instanceID);
+      this._deleteAudioChannelFromInterruptedAudioChannels(audioChannel);
+      this._resumeAudioChannels();
+    },
+
+    _handle_appopened: function(evt) {
+      this._updateTopMostWindow();
+    },
+
+    _handle_appclosed: function(evt) {
+      this._updateTopMostWindow();
+    },
+
+    _updateTopMostWindow: function() {
+      var topMostWindow = this._getTopMostWindow();
+      if (topMostWindow !== this._topMostWindow2) {
+        this._topMostWindow2 = topMostWindow;
+        this._handle_hierarchytopmostwindowchanged();
+      }
+    },
+
+    _getTopMostWindow: function() {
+      /*var topMostWindowManager;
+      this._ui_list.some(function(module) {
+        if (module.getActiveWindow && module.isActive()) {
+          topMostWindowManager = module;
+          return true;
+        }
+      }, this);
+      return topMostWindowManager &&
+             topMostWindowManager.getActiveWindow() &&
+             topMostWindowManager.getActiveWindow().getTopMostWindow();*/
+      return AppWindowManager.getActiveApp().getTopMostWindow();
+    },
+
+    /**
+     * Handle the audio chanel when the app is in foreground or background.
+     */
+    _handle_hierarchytopmostwindowchanged: function() {
+      if (this._topMostWindow && this._topMostWindow.audioChannels) {
+        // Normal channel could not play in background.
+        this.debug(this._topMostWindow.name + ' is closed');
+        var audioChannel = this._topMostWindow.audioChannels.get('normal');
+        if (audioChannel && audioChannel.isPlaying()) {
+          audioChannel.setPolicy({ isAllowedToPlay: false });
+          this._handleAudioChannel(audioChannel);
+        }
+      }
+      this._topMostWindow = this._getTopMostWindow();
+      if (this._topMostWindow) {
+        this.debug(this._topMostWindow.name + ' is opened');
+        this._resumeAudioChannels(this._topMostWindow);
+      }
+    },
+
+    /**
+     * Mute the System app's audio channels after they are registered.
+     */
+    _handle_systemwindowaudiochannelsregistered: function() {
+      this._muteSystemAudioChannels();
+    },
+
+    /**
+     * Play or pause the new audio channel and the active audio channels.
+     *
+     * @param {AudioChannelController} audioChannel The new audio channel.
+     */
+    _manageAudioChannels: function(audioChannel) {
+      if (audioChannel.isActive()) {
+        var isBackground = this._isAudioChannelInBackground(audioChannel);
+        this.audioChannelPolicy.applyPolicy(
+          audioChannel,
+          this._activeAudioChannels,
+          {
+            isNewAudioChannelInBackground: isBackground
+          }
+        );
+        this._activeAudioChannels.forEach((audioChannel) => {
+          this._handleAudioChannel(audioChannel);
+        });
+        this._handleAudioChannel(audioChannel);
+        var channel = { channel: audioChannel.name };
+        if (!isBackground) {
+          this.publish('visibleaudiochannelchanged', channel);
+        }
+        this.publish('audiochannelchanged', channel);
+      } else {
+        this._resetAudioChannel(audioChannel);
+        this._resumeAudioChannels();
+        this.publish('audiochannelchanged', { channel: 'none' });
+      }
+    },
+
+    /**
+     * Set the audio channel as default state as muted,
+     * and fade in the faded out audio channels.
+     *
+     * @param {AudioChannelController} audioChannel The audio channel.
+     */
+    _resetAudioChannel: function(audioChannel) {
+      audioChannel.setPolicy({ isAllowedToPlay: false });
+      this._handleAudioChannel(audioChannel);
+      audioChannel.name === 'notification' &&
+        this._fadeInFadedOutAudioChannels();
+    },
+
+    /**
+     * Handle the audio channel
+     * and update `_activeAudioChannels` and `_interruptedAudioChannels`.
+     *
+     * @param {AudioChannelController} audioChannel The audio channel.
+     */
+    _handleAudioChannel: function(audioChannel) {
+      var policy = audioChannel.proceedPolicy().getPolicy();
+      if (policy.isAllowedToPlay) {
+        this._activeAudioChannels.set(
+          audioChannel.instanceID,
+          audioChannel
+        );
+        this.debug('Playing ' + audioChannel.instanceID);
+      } else {
+        this._activeAudioChannels.delete(audioChannel.instanceID);
+        if (policy.isNeededToResumeWhenOtherEnds) {
+          this._interruptedAudioChannels.push(audioChannel);
+          this.debug('Interrupted ' + audioChannel.instanceID);
+        }
+      }
+    },
+
+    /**
+     * Fade in all faded out audio channels.
+     */
+    _fadeInFadedOutAudioChannels: function() {
+      this._activeAudioChannels.forEach((audioChannel) => {
+        audioChannel.isFadingOut() && audioChannel
+          .setPolicy({ isNeededToFadeOut: false })
+          .proceedPolicy();
+      });
+    },
+
+    /**
+     * Resume interrupted audio channels.
+     *
+     * @param {AppWindow} [app] The app window in foreground.
+     */
+    _resumeAudioChannels: function(app) {
+      // FIXME: The `app` param should always have `audioChannels`,
+      // then we don't need to check it.
+      // Resume the app's audio channels.
+      app && app.audioChannels && app.audioChannels.forEach((audioChannel) => {
+        audioChannel.isActive() && this._manageAudioChannels(audioChannel);
+        if (audioChannel.isPlaying()) {
+          this._deleteAudioChannelFromInterruptedAudioChannels(audioChannel);
+        }
+      });
+      // Resume the latest interrupted audio channel.
+      var audioChannel;
+      var length = this._interruptedAudioChannels.length;
+      if (this._activeAudioChannels.size === 0 && length) {
+        audioChannel = this._interruptedAudioChannels[length - 1];
+        audioChannel.setPolicy({ isAllowedToPlay: true });
+        this._handleAudioChannel(audioChannel);
+        audioChannel.isPlaying() && this._interruptedAudioChannels.pop();
+      }
+    },
+
+    /**
+     * Delete the audio channel from `_interruptedAudioChannels` array.
+     *
+     * @param {AudioChannelController} audioChannel
+     * The audio channel want to delete.
+     */
+    _deleteAudioChannelFromInterruptedAudioChannels: function(audioChannel) {
+      var index = this._interruptedAudioChannels
+        .findIndex(function(interruptedAudioChannel) {
+          return interruptedAudioChannel.instanceID ===
+            audioChannel.instanceID;
+      });
+      index !== -1 && this._interruptedAudioChannels.splice(index, 1);
+    },
+
+    /**
+     * Check the audio channel is in background or not.
+     *
+     * @param {AudioChannelController} audioChannel The audio channel.
+     * @retrun {Boolean}
+     */
+    _isAudioChannelInBackground: function(audioChannel) {
+      var isAudioChannelInBackground = true;
+      if ((this._topMostWindow &&
+          this._topMostWindow.instanceID === audioChannel.app.instanceID) ||
+          (audioChannel.isActive() && audioChannel.app.isInputMethod)) {
+        isAudioChannelInBackground = false;
+      }
+      return isAudioChannelInBackground;
+    },
+
+    _muteSystemAudioChannels: function() {
+      var audioChannels = this.service.query('SystemWindow.getAudioChannels');
+      if (!this._isSystemMuted && audioChannels && audioChannels.size) {
+        audioChannels.forEach((audioChannel, name) => {
+          this._sendContentEvent({
+            type: 'system-audiochannel-mute', name: name, isMuted: true
+          });
+        });
+        this._isSystemMuted = true;
+      }
+    },
+
+    /**
+     * Send MozContentEvent to control the audio chanenl in System app.
+     *
+     * @param {Object} detail The arguments for passing to Gecko.
+     * @param {Object} detail.type The operation for the audio channel.
+     */
+    _sendContentEvent: function(detail) {
+      var evt = new CustomEvent('mozContentEvent', { detail: detail });
+      window.dispatchEvent(evt);
+    }
+  });
+}());
diff --git a/tv_apps/smart-system/js/core.js b/tv_apps/smart-system/js/core.js
index 404defd..dbf8aac 100644
--- a/tv_apps/smart-system/js/core.js
+++ b/tv_apps/smart-system/js/core.js
@@ -10,6 +10,10 @@
   var Core = function() {
   };
 
+  Core.SUB_MODULES = [
+    'AudioChannelService'
+  ];
+
   Core.SERVICES = [
     'getAPI'
   ];
diff --git a/tv_apps/smart-system/js/system_window.js b/tv_apps/smart-system/js/system_window.js
new file mode 100644
index 0000000..b1e5074
--- /dev/null
+++ b/tv_apps/smart-system/js/system_window.js
@@ -0,0 +1,82 @@
+/* global AudioChannelController */
+/* global BaseModule */
+'use strict';
+
+(function() {
+  /**
+   * SystemWindow is a placeholder for the system app's mozbrowser iframe
+   * but with no actual UI.
+   * We will use mozChromeEvent/mozContentEvent to communicate with shell.js
+   * to use the actual mozbrowser iframe of the system app.
+   */
+  var SystemWindow = function() {};
+
+  SystemWindow.STATES = [
+    'getAudioChannels'
+  ];
+
+  SystemWindow.EVENTS = [
+    'mozSystemWindowChromeEvent'
+  ];
+
+  BaseModule.create(SystemWindow, {
+    name: 'SystemWindow',
+    EVENT_PREFIX: 'systemwindow',
+    DEBUG: false,
+    // The fake app window ID of System app.
+    instanceID: null,
+    // The audio channels belong to System app.
+    audioChannels: null,
+    // Know an AppWindow object is for System app or other apps. 
+    isSystem: true,
+
+    /**
+     * Initial the module.
+     */
+    _start: function() {
+      this.instanceID = 'systemAppID';
+      this.audioChannels = new Map();
+    },    
+
+    /**
+     * Handle mozSystemWindowChromeEvent event.
+     *
+     * @param {Event} evt The event to handle.
+     */
+    _handle_mozSystemWindowChromeEvent: function(evt) {
+      var detail = evt.detail;
+      switch (detail.type) {
+        // Send the event after system is first time painted
+        // becuase of Bug 1167465.
+        case 'system-first-paint':
+          // Get System app's audio channels.
+          this._sendContentEvent({ type: 'system-audiochannel-list' });
+          break;
+
+        case 'system-audiochannel-list':
+          detail.audioChannels.forEach((name) => {
+            this.audioChannels.set(
+              name, new AudioChannelController(this, { name: name })
+            );
+          });
+          this.publish('audiochannelsregistered');
+          break;
+      }
+    },
+
+    getAudioChannels: function() {
+      return this.audioChannels;
+    },
+
+    /**
+     * Send MozContentEvent to control the audio chanenl in System app.
+     *
+     * @param {Object} detail The arguments for passing to Gecko.
+     * @param {Object} detail.type The operation for the audio channel.
+     */
+    _sendContentEvent: function(detail) {
+      var evt = new CustomEvent('mozContentEvent', { detail: detail });
+      window.dispatchEvent(evt);
+    }
+  });
+}());
-- 
2.3.2 (Apple Git-55)

